# Note0802.md




## continue [简明 python 教程](https://bop.mol.uno/)



## gitbook ???

好几个域名



## [从浏览器多进程到 js 单线程](https://segmentfault.com/a/1190000012925872)


### 进程和线程的区分

进程是 cpu 资源分配的最小单位

线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程


### 浏览器是多进程的

- 浏览器是多进程的

- 浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）

- 简单点理解，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。


### 浏览器包含哪些进程


#### Browser进程：浏览器的主进程（负责协调、主控），只有一个。

作用有：

* 负责浏览器界面显示，与用户交互。如前进，后退等

* 负责各个页面的管理，创建和销毁其他进程

* 将Renderer进程得到的内存中的Bitmap，绘制到用户界面上

* 网络资源的管理，下载等

#### 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建

#### GPU进程：最多一个，用于3D绘制等

#### 浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为

* 页面渲染，脚本执行，事件处理等

#### 在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）

* 浏览器有时会将多个进程合并（譬如打开多个空白标签页后，会发现多个空白标签页被合并成了一个进程）	


### 浏览器多进程的优势


* 避免单个page crash影响整个浏览器

* 避免第三方插件crash影响整个浏览器

* 多进程充分利用多核优势

* 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性

简单点理解：如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；

当然缺点的话，内存等资源消耗也会更大，有点**空间换时间**的意思。


### 浏览器内核————渲染进程

**浏览器的渲染进程是多线程的**

#### GUI渲染线程



## segmentfault




## sublime 添加编辑器组

[sublime VS. VS code](https://zhuanlan.zhihu.com/p/37888186)


## 亭子飞乐鸟

next mouth








/// <reference path="../qunit2.3.2/qunit-2.3.2.js" />
/// <reference path="../Resources/dynamsoft.webtwain.intellisense.js" />
/// <reference path="../Resources/dynamsoft.webtwain.intellisense.nonvs.js" />


/*
Key Testing Points:
1.verify the errorcode and errorstring
2.verify the images dpi and resolution,save to local and then reload and get the properties via apis
3.different image types
4.image save to local and wait manual check
*/

function BasicScanning() {
    QUnit.module("BasicScanning", {
        before: function () {
            // prepare something once for all tests
            //Dynamsoft.WebTwainEnv.Load();
            console.log("before");
        },
        beforeEach: function () {
            // prepare something before each test
            QUnit.config.autostart = false;
            //Start the initialization of DWT objects.
            DWObject.IfShowFileDialog = false;
            DWObject.RemoveAllImages();
            DWObject.IfShowUI = false;
            console.log("before each");
        },
        afterEach: function () {
            // clean up after each test
            //Dynamsoft.WebTwainEnv.AutoLoad = false;
            //Dynamsoft.WebTwainEnv.Load();
            DWObject.RemoveAllImages();
            console.log("after each");
        },
        after: function () {
            // clean up once after all tests are done
            //Dynamsoft.WebTwainEnv.Load();
            console.log("after");
        }
    });


    function OnSuccess() {
        console.log('successful');
    }

    function OnFailure(errorCode, errorString) {
        console.log(errorString);
    }


    //defalt & _obj & callback
    //QUnit.module("AcquireImage");

    QUnit.test("AcquireImage_defalt", function (assert) {
        var done = assert.async();
        DWObject.OpenSource();
        DWObject.AcquireImage(
            function () {
                done();
                assert.equal(1, DWObject.HowManyImagesInBuffer, "defalt acquired 1 image");
            },
            function () {
                done();
                console.log("acquire failed");
            });
    });


    QUnit.test("AcquireImage_obj", function (assert) {
        var done = assert.async();
        DWObject.OpenSource();
        var _obj = {};
        _obj.IfShowUI = false;
        DWObject.AcquireImage(_obj,
            function () {
                done();
                assert.equal(1, DWObject.HowManyImagesInBuffer, "obj acquired 1 image");
            },
            function () {
                done();
                console.log("acquire failed");
            });
    });

    //only Mac && Windows
    //bitDepth 1,8,24,reset as 4
    //QUnit.module("BitDepth");

    QUnit.test("BitDepth_1bit", function (assert) {
        if (navigator.platform == "Linux" || navigator.platform == "X11")
            console.log("only for Mac & Windows")
        else {
            DWObject.OpenSource();
            DWObject.PixelType = 0;
            assert.equal(DWObject.BitDepth, 1, "BitDepth 1");
        }
    });

    QUnit.test("BitDepth_8bit", function (assert) {
        if (navigator.platform == "Linux" || navigator.platform == "X11")
            console.log("only for Mac & Windows")
        else {
            DWObject.OpenSource();
            DWObject.PixelType = 1;
            assert.equal(DWObject.BitDepth, 8, "BitDepth 8");
        }
    });

    QUnit.test("BitDepth_24bit", function (assert) {
        if (navigator.platform == "Linux" || navigator.platform == "X11")
            console.log("only for Mac & Windows")
        else {
            DWObject.OpenSource();
            DWObject.PixelType = 2;
            assert.equal(DWObject.BitDepth, 24, "BitDepth 24");
        }
    });

    QUnit.test("BitDepth_4bit", function (assert) {
        if (navigator.platform == "Linux" || navigator.platform == "X11")
            console.log("only for Mac & Windows")
        else {
            DWObject.OpenSource();
            DWObject.PixelType = 1;
            DWObject.BitDepth = 4;
            assert.equal(DWObject.BitDepth, 4, "BitDepth 4");
        }
    });


    //QUnit.module("CloseSource");

    QUnit.test("CloseSource_OpenToClose", function (assert) {
        DWObject.OpenSource();
        if (DWObject.DataSourceStatus==1) {
            DWObject.CloseSource();
            assert.equal(DWObject.DataSourceStatus,0, "source closed");
        }
        else
            console.log(errorString);
    });

    //After DisableSource() is called
    //the Source is still open and you can continue to acquire images
    //QUnit.module("DisableSource");

    QUnit.test("DisableSource_continueAcquir", function (assert) {
        DWObject.OpenSource();
        if (DWObject.DataSourceStatus==1) {
            DWObject.DisableSource();
            
            assert.ok(true,DWObject.DataSourceStatus);
        }
        else
            console.log("failure");
    });

    //check index
    //QUnit.module("IfAppendImage");

    QUnit.test("IfAppendImage_true", function (assert) {
        if (DWObject.OpenSource()) {
            var done = assert.async(10);
            var _obj = {};
            _obj.IfShowUI = false;
            _obj.IfAppendImage = true;
            var _currentImageIndexInBuffer;
            for (var i = 0; i < 10; i++) {
                DWObject.AcquireImage(_obj,
                    function () {
                        done();
                        _currentImageIndexInBuffer = DWObject.CurrentImageIndexInBuffer;
                        assert.equal(DWObject.HowManyImagesInBuffer - 1, _currentImageIndexInBuffer, "append image to the last image successful");
                    });
            }
        }
    });

    QUnit.test("IfAppendImage_false", function (assert) {
        if (DWObject.OpenSource()) {
            var done = assert.async(10);
            var _obj = {};
            _obj.IfShowUI = false;
            _obj.IfAppendImage = false;
            for (var i = 0; i < 10; i++) {
                DWObject.AcquireImage(_obj,
                    function () {
                        done();
                        _currentImageIndexInBuffer = DWObject.CurrentImageIndexInBuffer;
                        assert.equal(0, _currentImageIndexInBuffer, "append image to the first image successful");
                    });
            }
        }
    });

    ////IfShowUI() true or false 
    ////IfDisableSourceAfterAcquire() true or false
    //QUnit.module("IfDisableSourceAfterAcquire");

    //QUnit.test("IfDisableSourceAfterAcquire_defalt", function (assert) {
    //    var _ifDisableSourceAfterAcquire_def = DWObject.IfDisableSourceAfterAcquire;
    //    assert.ok(_ifDisableSourceAfterAcquire_def, "defalt true");
    //});

    //QUnit.test("IfDisableSourceAfterAcquire_true_IfShowUI_true", function (assert) {
    //    DWObject.IfDisableSourceAfterAcquire = true;
    //    DWObject.IfShowUI = true;
    //    //DWObject.SelectSource();
    //    var _ifselectSource = DWObject.SelectSource;
    //    assert.ok(_ifselectSource, "UI show up & closed automatically");
    //});

    //QUnit.test("IfDisableSourceAfterAcquire_false_IfShowUI_true", function (assert) {
    //    DWObject.IfDisableSourceAfterAcquire = false;
    //    DWObject.IfShowUI = true;
    //    var _ifselectSource = DWObject.SelectSource;
    //    assert.ok(_ifselectSource, "UI show up & closed closed manually");
    //});

    //QUnit.test("IfDisableSourceAfterAcquire_true_IfShowUI_false", function (assert) {
    //    DWObject.IfDisableSourceAfterAcquire = true;
    //    DWObject.IfShowUI = false;
    //    var _ifselectSource = DWObject.SelectSource;
    //    assert.ok(_ifselectSource, "UI did not show up");
    //});

    //QUnit.test("IfDisableSourceAfterAcquire_false_IfShowUI_false", function (assert) {
    //    DWObject.IfDisableSourceAfterAcquire = false;
    //    DWObject.IfShowUI = false;
    //    DWObject.SelectSource();
    //    var _ifselectSource = DWObject.SelectSource;
    //    assert.ok(_ifselectSource, "UI did not show up");
    //});

    // Duplex is a read-only property
    // can not reset Duplex in the test case
    //QUnit.module("IfDuplexEnabled");

    QUnit.test("IfDuplexEnabled_defalt", function (assert) {
        var _ifDuplexEnabled = DWObject.IfDuplexEnabled;
        assert.notOk(_ifDuplexEnabled,"dafalt do not support Duplex");
    });

    QUnit.test("IfDuplexEnabled_true", function (assert) {
        DWObject.IfDuplexEnabled = true;
        var _ifDuplexEnabled = DWObject.IfDuplexEnabled;
        assert.notOk(_ifDuplexEnabled, "support Duplex");
    });


    //defalt true 
    //test result false
    //QUnit.module("IfFeederEnabled");
     
    QUnit.test("IfFeederEnabled_defalt", function (assert) {
        var _ifFeederEnabled_def = DWObject.IfFeederEnabled;
        assert.ok(_ifFeederEnabled_def, "ADF is enabled for scanning");
    });

    QUnit.test("IfFeederEnabled_false", function (assert) {
        DWObject.IfFeederEnabled = false;
        var _ifFeederEnabled_f = DWObject.IfFeederEnabled;
        assert.notOk(_ifFeederEnabled_f, "ADF is disabled for scanning");
    });


    //QUnit.module("IfShowUI");

    //QUnit.test("IfShowUI_defalt", function (assert) {
    //    var _ifShowUI_def = DWObject.SelectSource;
    //    assert.ok(_ifShowUI_def, "UI show up");
    //});

    //QUnit.test("IfShowUI_false", function (assert) {
    //    DWObject.IfShowUI = false;
    //    var _ifShowUI_f = DWObject.SelectSource;
    //    assert.ok(_ifShowUI_f, "UI did not show up");
    //});


    //Mac only
    //0, 3, 4
    //QUnit.module("ImageCaptureDriverType");

    QUnit.test("ImageCaptureDriverType_0", function (assert) {
        if (navigator.platform == "Mac68K" || navigator.platform == "MacPPC" || navigator.platform == "Macintosh" || navigator.platform == "MacIntel") {
            DWObject.ImageCaptureDriverType = 0;
            var _imageCaptureDriverType_0 = DWObject.ImageCaptureDriverType;
            assert.equal(_imageCaptureDriverType_0, 0, "document scanning on macOS");
        }
        else
            assert.ok(true, "not for win or linux");
    });

    QUnit.test("ImageCaptureDriverType_3", function (assert) {
        if (navigator.platform == "Mac68K" || navigator.platform == "MacPPC" || navigator.platform == "Macintosh" || navigator.platform == "MacIntel") {
            DWObject.ImageCaptureDriverType = 3;
            var _imageCaptureDriverType_3 = DWObject.ImageCaptureDriverType;
            assert.equal(_imageCaptureDriverType_3, 3, "document scanning on macOS");
        }
        else
            assert.ok(true, "not for win or linux");
    });

    QUnit.test("ImageCaptureDriverType_4", function (assert) {
        if (navigator.platform == "Mac68K" || navigator.platform == "MacPPC" || navigator.platform == "Macintosh" || navigator.platform == "MacIntel") {
            DWObject.ImageCaptureDriverType = 4;
            var _imageCaptureDriverType_4 = DWObject.ImageCaptureDriverType;
            assert.equal(_imageCaptureDriverType_4, 4, "document scanning on macOS");
        }
        else
            assert.ok(true, "not for win or linux");
    });


    //QUnit.module("OnPostAllTansfers");

    QUnit.test("OnPostAllTansfers", function (assert) {
        var done = assert.async(10);
        var _i = 0;
        DWObject.RegisterEvent('OnPostAllTransfers',
            function () {
                done();
                _i++;
                assert.equal(DWObject.HowManyImagesInBuffer, _i, "Images In Buffer " + DWObject.HowManyImagesInBuffer + " successsful");
            });
        DWObject.OpenSource();
        DWObject.IfShowUI = false;
        for (var i = 0; i < 10; i++)
            DWObject.AcquireImage(OnSuccess, OnFailure);
    });


    //QUnit.module("OnPostTransfer");

    QUnit.test("OnPostTransfer_currentImageBuffer", function (assert) {
        var done = assert.async(10);
        var _i = 0;
        DWObject.CurrentImageIndexInBuffer = 0;
        DWObject.RegisterEvent('OnPostTransfer',
            function () {
                done();
                //assert.equal(_i, DWObject.CurrentImageIndexInBuffer,"current image in buffer "+DWObject.HowManyImagesInBuffer+" successful");
                assert.equal(DWObject.CurrentImageIndexInBuffer, _i, "curren image buffer " + DWObject.CurrentImageIndexInBuffer + " successful");
                _i++;
            });
        DWObject.OpenSource();
        DWObject.IfShowUI = false;
        function Recursion() {
            if (_i < 10) {
                DWObject.AcquireImage(Recursion, OnFailure);
            }
        }
        DWObject.AcquireImage(Recursion, OnFailure);
    });


    //QUnit.module("OpenSource");

    QUnit.test("OpenSource_true", function (assert) {
        if (DWObject.CloseSource()) {
            var _openSource = DWObject.OpenSource();
            assert.ok(_openSource, "source opened");
        }
        else
            console.log("failure");
    });


    ////Set this property after OpenSource() and before AcquireImage()
    //QUnit.module("PageSize");

    //QUnit.test("PageSize_A", function (assert) {
    //    DWObject.OpenSource();
    //    for (let i = 0; i < 54; i++) {
    //        DWObject.PageSize = i;
    //        assert.equal(DWObject.PageSize, i, "page size" + i);
    //    }
    //});


    ////Set this property after OpenSource() and before AcquireImage()
    //QUnit.module("PixelType");

    //QUnit.test("PixelType_A", function (assert) {
    //    DWObject.OpenSource();
    //    for (let i = 0; i < 17; i++) {
    //        DWObject.PixelType = i;
    //        assert.equal(DWObject.PixelType, i, "pixel type" + i);
    //    }
    //});


    //Set this property after OpenSource() and before AcquireImage()
    //QUnit.module("Resolution");

    QUnit.test("Resolution_res", function (assert) {
        DWObject.OpenSource();
        if (DWObject.Resolution) {
            DWObject.Resolution = 300;
            assert.equal(DWObject.Resolution, 300, "return successfel and reset resolution 300");
        }
    });


    //QUnit.module("SelectSourceByIndex");

    QUnit.test("SelectSourceByIndex_0", function (assert) {
        if (DWObject.CloseSource()) {
            var _selectSourceByIndex_0 = DWObject.SelectSourceByIndex(0);
            assert.ok(_selectSourceByIndex_0, "select first source")
        }
    });

    QUnit.test("SelectSourceByIndex_last", function (assert) {
        if (DWObject.CloseSource()) {
            var _sourceCount = DWObject.SourceCount;
            var _selectSourceByIndex_last = DWObject.SelectSourceByIndex(_sourceCount - 1);
            assert.ok(_selectSourceByIndex_last, "select last source")
        }
    });


    ////14.1 SelectSource(onSuccess,onFailure) 
    //QUnit.module("SelectSource");

    //QUnit.test("SelectSource_syn", function (assert) {
    //    if (DWObject.CloseSource()) {
    //        if (DWObject.SelectSource) {
    //            var _openSource_syn = DWObject.OpenSource;
    //            assert.ok(_openSource_syn, "defalt select source and opened successfully");
    //        }
    //    }
    //});

    //QUnit.test("SelectSource_asy", function (assert) {
    //    if (DWObject.CloseSource()) {
    //        var done = assert.async();
    //        DWObject.SelectSource(
    //            function () {
    //                done();
    //                assert.equal(DWObject.EnableSource(), true, "source opened");
    //                assert.equal(DWObject.__sourceName, "TWAIN2 FreeImage Software Scanner");
    //            },
    //            function () {
    //                done();
    //                assert.equal(0, DWObject.ErrorCode, DWObject.ErrorCode);
    //                assert.equal(DWObject.ErrorString, "Successful.", DWObject.ErrorString);
    //            }
    //        );
    //    }
    //});


    //used before OpenSource()
    //QUnit.module("SetOpenSourceTimeout");

    QUnit.test("SetOpenSourceTimeout_inT", function (assert) {
        DWObject.CloseSource();
        DWObject.SetOpenSourceTimeout(3000);
        var _openSource_inT = DWObject.OpenSource();
        assert.ok(_openSource_inT, "openSource in the time");
    });

    QUnit.test("SetOpenSourceTimeout_outT", function (assert) {
        if (DWObject.CloseSource()) {
            DWObject.SetOpenSourceTimeout(1);
            var _openSource_outT = DWObject.OpenSource();
            assert.notOk(_openSource_outT, "openSource out the time");
        }
    });


    //not for Mac
    //QUnit.module("SourceCount");

    QUnit.test("SourceCount_all", function (assert) {
        if (navigator.platform != "Mac68K" || navigator.platform != "MacPPC" || navigator.platform != "Macintosh" || navigator.platform != "MacIntel") {
            var _sourceCount = DWObject.SourceCount;
            assert.ok(_sourceCount, "source count" + _sourceCount);
        }
    });


}
